#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# (c) 2018-2019 gmrandazzo@gmail.com
# This file is part of DeepMolecularNetwork.
# You can use,modify, and distribute it under
# the terms of the GNU General Public Licenze, version 3.
# See the file LICENSE for details

import sys
import string
import subprocess
import os
import numpy as np
from pathlib import Path

def nsplit(s, delim=None):
  return [x for x in s.split(delim) if x]

class POINT(object):
  def __init__(self, x, y, z):
    self.x = x
    self.y = y
    self.z = z

class MOLECULE(object):
  def __init__(self):
    self.name = ""
    self.coord = []
    self.atomtype = []
    self.charge = []
    self.radius = []
    self.axis = []
    self.theta = []
    self.dtheta = 0

  def getNatoms(self):
    return len(self.coord)

  def rotate(self, vec, axis_, angle_):
    """Rodrigues rotation formula"""
    axis_ = np.array(axis_)
    vec = np.array(vec)
    axis_ = axis_ / np.linalg.norm(axis_)
    term1 = vec * np.cos(angle_)
    term2 = (np.cross(axis_, vec)) * np.sin(angle_)
    term3 = axis_ * ((1 - np.cos(angle_)) * axis_.dot(vec))
    return term1 + term2 + term3

  def randomRotation(self):
    self.rnd_rot = True
    self.uni_rot = False

  def uniformRotation(self, nrot=100.0):
    self.rnd_rot = False
    self.uni_rot = True
    # Step 1
    self.axis = np.random.standard_normal((3,))
    self.axis /= np.linalg.norm(self.axis)
    self.theta = 0.0
    self.dtheta = 2*np.pi/float(nrot)

  def nextRotation(self):
    if self.rnd_rot == True:
      # Step 1
      self.axis = np.random.standard_normal((3,))
      self.axis /= np.linalg.norm(self.axis)
      # Step 2
      self.theta = np.random.uniform(0, 2*np.pi)
    else:
      # Step 2
      self.theta += self.dtheta

    # Step 3 rotate the vector around axis and theta
    for i in range(self.getNatoms()):
      vec = [self.coord[i].x, self.coord[i].y, self.coord[i].z]
      self.coord[i].x, self.coord[i].y, self.coord[i].z = self.rotate(vec, self.axis, self.theta)


def getVDWRadius(asymbl_):
  asymbl = asymbl_.lower()
  if asymbl == "h":
    return 1.20
  elif asymbl == "f":
    return 1.47
  elif asymbl == "cl":
    return 1.75
  elif asymbl == "br":
    return 1.85
  elif asymbl == "i":
    return 1.98
  elif asymbl == "o":
    return 1.52
  elif asymbl == "n":
    return 1.55
  elif asymbl == "c":
    return 1.70
  elif asymbl == "p":
    return 1.80
  elif asymbl == "s":
    return 1.80
  else:
    print("Error! VDW radis not found [%s]" % (asymbl_))
    return 9.99

def acread(acin):
  m = MOLECULE()
  fi = open(acin, "r")
  m.name = Path(acin).resolve().stem
  for line in fi:
    if "ATOM" in line:
      v = nsplit(line.strip(), " ")
      m.coord.append(POINT(float(v[5]), float(v[6]), float(v[7])))
      m.atomtype.append(v[2])
      m.charge.append(float(v[8]))
      m.radius.append(getVDWRadius(v[2]))
    else:
      continue
  fi.close()
  return m

def writepqr(m, pqrout):
  fo = open(pqrout, "w")
  fo.write("REMARK   1 PQR file generated by autoAPBS version 1 0 0\n")
  fo.write("REMARK   1\n")
  fo.write("REMARK   1 MOLECULE: %s\n" % (pqrout.split(".")[0]))
  fo.write("REMARK   1\n")
  for i in range(m.getNatoms()):
    fo.write("ATOM %6d %3s  UNL A   1      %6.3f  %6.3f  %6.3f %7.4f %6.2f\n" % (int(i+1), m.atomtype[i], m.coord[i].x, m.coord[i].y, m.coord[i].z, m.charge[i], m.radius[i]))
  fo.write("TER\nEND\n")
  fo.close()

def ac2pqr(acin, pqrout):
  """
  REMARK   1 PQR file generated by MolDesc version 1 0 0
  REMARK   1
  REMARK   1 MOLECULE: h2o
  REMARK   1
  ATOM      1  O   UNL A   1      -4.914   2.221   0.016 -0.5200 1.5200
  ATOM      2  H   UNL A   1      -3.946   2.193  -0.021  0.2249 1.2000
  ATOM      3  H   UNL A   1      -5.193   1.648  -0.714  0.2249 1.2000
  TER
  END
  """
  fi = open(acin, "r")
  fo = open(pqrout, "w")
  fo.write("REMARK   1 PQR file generated by autoAPBS version 1 0 0\n")
  fo.write("REMARK   1\n")
  fo.write("REMARK   1 MOLECULE: %s\n" % (acin.split(".")[0]))
  fo.write("REMARK   1\n")
  for line in fi:
    if "ATOM" in line:
      v = nsplit(line.strip(), " ")
      fo.write("ATOM %6d %3s  UNL A   1      %6.3f  %6.3f  %6.3f %7.4f %6.2f\n" % (int(v[1]), v[2], float(v[5]), float(v[6]), float(v[7]), float(v[8]), float(getVDWRadius(v[2]))))
    else:
      continue
  fo.write("TER\nEND\n")
  fi.close()
  fo.close()

def mpdb2pqr(mpdbin, pqrout):
  """
  REMARK   1 PQR file generated by MolDesc version 1 0 0
  REMARK   1
  REMARK   1 MOLECULE: h2o
  REMARK   1
  ATOM      1  O   UNL A   1      -4.914   2.221   0.016 -0.5200 1.5200
  ATOM      2  H   UNL A   1      -3.946   2.193  -0.021  0.2249 1.2000
  ATOM      3  H   UNL A   1      -5.193   1.648  -0.714  0.2249 1.2000
  TER
  END
  """
  fi = open(mpdbin, "r")
  fo = open(pqrout, "w")
  fo.write("REMARK   1 PQR file generated by autoAPBS version 1 0 0\n")
  fo.write("REMARK   1\n")
  fo.write("REMARK   1 MOLECULE: %s\n" % (mpdbin.split(".")[0]))
  fo.write("REMARK   1\n")
  for line in fi:
    if "ATOM" in line:
      v = nsplit(line.strip(), " ")
      fo.write("ATOM %6d %3s  UNL A   1      %6.3f  %6.3f  %6.3f %7.4f %6.2f\n" % (int(v[1]), v[2], float(v[5]), float(v[6]), float(v[7]), float(v[8]), float(v[9])))
    else:
      continue
  fo.write("TER\nEND\n")
  fi.close()
  fo.close()
